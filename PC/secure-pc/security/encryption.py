from Cryptodome.Cipher import AES, PKCS1_OAEP
from Cryptodome.Util.Padding import pad, unpad
from Cryptodome.Hash import SHA256

from .interfaces import EncryptionInterface, Key


class RSAEncryption(EncryptionInterface):
    def __init__(self, key: Key):
        """
        :param key: a key generated by RSAKeyManager
        """
        self.key = key

    def encrypt(self, message: bytes, **kwargs) -> bytes:
        cipher = PKCS1_OAEP.new(self.key, hashAlgo=SHA256)
        return cipher.encrypt(message)

    def decrypt(self, message: bytes, **kwargs) -> bytes:
        cipher = PKCS1_OAEP.new(self.key, hashAlgo=SHA256)
        return cipher.decrypt(message)


class AES256Encryption(EncryptionInterface):
    MODE_ECB = AES.MODE_ECB
    MODE_CBC = AES.MODE_CBC
    MODE_CFB = AES.MODE_CFB
    MODE_OFB = AES.MODE_OFB
    MODE_CTR = AES.MODE_CTR
    MODE_EAX = AES.MODE_EAX

    def __init__(self, key: Key, mode: int = MODE_ECB):
        """
        :param key: a key generated by AES256KeyManager
        :param mode: encryption mode to be used (use one of the class constants)
        """
        self.key = key
        self.mode = mode
        self.iv = None
        self.nonce = None

    def encrypt(self, message: bytes, **kwargs) -> bytes:
        """
        Encrypt the message using AES-256. The message is padded
        using PKCS7.
        If using EAX mode, the verification MAC will be appended to
        the data.
        :Keyword Arguments:
        *    *mode* (``int``) --
                mode of operation for encryption
                will change the default mode that may have been
                provided in the constructor
        *    *iv* (``byte string``) --
                initialization vector (for CBC, CFB and OFB modes) - 16 bytes long
                if not provided but required, a random IV is
                generated and stored as a class member
        *    *nonce* (``byte string``) --
                a value that must not be repeated with this key
                required for CTR and EAX modes
                length must be in **[0..15]**, recommended **8**
                if not provided but required, a random nonce is
                generated and stored as a class member
        """

        message = pad(message, AES.block_size)

        mode = kwargs.get('mode')
        if mode is not None:
            self.mode = mode

        iv = kwargs.get('iv')
        nonce = kwargs.get('nonce')

        if iv is not None:
            cipher = AES.new(self.key, self.mode, iv=iv)
        elif nonce is not None:
            cipher = AES.new(self.key, self.mode, nonce=nonce)
        else:
            cipher = AES.new(self.key, self.mode)

        if self.mode in (self.MODE_CBC, self.MODE_CFB, self.MODE_OFB):
            self.iv = cipher.IV
        elif self.mode in (self.MODE_CTR, self.MODE_EAX):
            self.nonce = cipher.nonce

        if self.mode == self.MODE_EAX:
            enc, tag = cipher.encrypt_and_digest(message)
            return enc + tag

        return cipher.encrypt(message)

    def decrypt(self, message: bytes, iv: bytes = None, *args, **kwargs) -> bytes:
        """
        Decrypt a message using AES-256. Message is assumed
        to be padded using PKCS7.
        If using EAX mode, the verification MAC is assumed to be
        appended to the data.
        :Keyword Arguments:
        *    *mode* (``int``) --
                mode of operation for encryption
                will change the default mode that may have been
                provided in the constructor
        *    *iv* (``byte string``) --
                initialization vector (for CBC, CFB and OFB modes) - 16 bytes long
        *    *nonce* (``byte string``) --
                a value that must not be repeated with this key
                required for CTR and EAX modes
                length must be in **[0..15]**, recommended **8**
        """
        mode = kwargs.get('mode')
        if mode is not None:
            self.mode = mode

        nonce = kwargs.get('nonce')

        if iv is not None:
            cipher = AES.new(self.key, self.mode, iv=iv)
            self.iv = cipher.IV
        elif nonce is not None:
            cipher = AES.new(self.key, self.mode, nonce=nonce)
            self.nonce = cipher.nonce
        else:
            cipher = AES.new(self.key, self.mode)

        if self.mode == self.MODE_EAX:
            plaintext = cipher.decrypt_and_verify(message[:-16], message[-16:])
        else:
            plaintext = cipher.decrypt(message)

        return unpad(plaintext, AES.block_size)
